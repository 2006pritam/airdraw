<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>AirDraw — draw in the air with your hand</title>
  <style>
    :root {
      --bg: #0b0e13;
      --panel: #131823;
      --text: #e9eefc;
      --muted: #8ea0c9;
      --accent: #5aa1ff;
      --accent-2: #6ee7b7;
      --danger: #ff6b6b;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --radius: 14px;
    }
    *{box-sizing:border-box}
    html,body{height:100%;background:var(--bg);color:var(--text);margin:0;font-family:Inter,ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"Apple Color Emoji","Segoe UI Emoji"}
    .app{display:grid;grid-template-columns:1fr 350px;gap:18px;max-width:min(1500px,95vw);margin:24px auto;align-items:start}
    .stage{position:relative;background:#0e121a;border-radius:var(--radius);overflow:hidden;box-shadow:var(--shadow);min-height:60vh}
    video{position:absolute;inset:0;width:100%;height:100%;object-fit:cover;transform:scaleX(-1);opacity:.4;filter:saturate(.9) contrast(1.05)}
    canvas#overlay, canvas#paint{position:absolute;inset:0;width:100%;height:100%}
    canvas#overlay{pointer-events:none}

    .hud{position:absolute;left:14px;bottom:14px;background:rgba(0,0,0,.45);backdrop-filter:blur(8px);border:1px solid rgba(255,255,255,.08);padding:10px 12px;border-radius:12px;display:flex;gap:10px;align-items:center}
    .dot{width:10px;height:10px;border-radius:999px;background:#888}
    .dot.live{background:var(--accent)}
    .hint{color:var(--muted);font-size:12px}

    .panel{position:sticky;top:18px;background:linear-gradient(180deg,rgba(255,255,255,.04),rgba(255,255,255,.02));border:1px solid rgba(255,255,255,.06);padding:16px 16px 12px;border-radius:var(--radius);box-shadow:var(--shadow)}
    .panel h2{margin:2px 0 12px;font-size:18px;letter-spacing:.2px}
    .row{display:flex;align-items:center;justify-content:space-between;gap:10px;margin:10px 0}
    .row label{font-size:14px;color:var(--muted)}
    .panel input[type=color]{width:44px;height:32px;border:none;background:#000;border-radius:8px;cursor:pointer}
    .panel input[type=range]{width:100%}
    .btns{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:8px}
    button{appearance:none;border:none;background:#1a2130;color:var(--text);padding:10px 12px;border-radius:12px;cursor:pointer;font-weight:600;transition:.2s transform,.2s background}
    button:hover{transform:translateY(-1px);background:#202b40}
    button.primary{background:linear-gradient(135deg,var(--accent),#4f46e5)}
    button.primary:hover{background:linear-gradient(135deg,#69afff,#6157ff)}
    button.ghost{background:#171d2a}
    button.danger{background:linear-gradient(135deg,#ff8181,var(--danger))}
    .kbd{font-family:ui-monospace,Menlo,Consolas,monospace;background:#0d1320;border:1px solid rgba(255,255,255,.08);padding:2px 6px;border-radius:8px;color:#c5d3ff}

    .tips{margin-top:10px;padding-top:10px;border-top:1px dashed rgba(255,255,255,.1);color:var(--muted);font-size:13px;line-height:1.45}
    .tips b{color:#cfe1ff}

    .toast{position:fixed;right:18px;bottom:18px;background:#101726;border:1px solid rgba(255,255,255,.09);padding:12px 14px;border-radius:12px;box-shadow:var(--shadow);display:none}
    .warn{color:#ffd166}
  </style>
</head>
<body>
  <div class="app">
    <div class="stage" id="stage">
      <video id="video" playsinline></video>
      <canvas id="overlay"></canvas>
      <canvas id="paint"></canvas>
      <div class="hud"><div class="dot" id="dot"></div><div class="hint" id="status">Waiting for camera…</div></div>
    </div>

    <aside class="panel">
      <h2>AirDraw Controls</h2>
      <div class="row"><label>Draw color</label><input type="color" id="color" value="#5aa1ff"></div>
      <div class="row"><label>Brush size <span id="sizeLabel" class="kbd">6px</span></label><input type="range" id="size" min="1" max="40" value="6"></div>
      <div class="row"><label>Pointer smoothing <span id="smoothLabel" class="kbd">0.35</span></label><input type="range" id="smooth" min="0" max="0.9" step="0.01" value="0.35"></div>
      <div class="row"><label>Pinch sensitivity <span id="pinchLabel" class="kbd">0.06</span></label><input type="range" id="pinch" min="0.03" max="0.12" step="0.005" value="0.06"></div>
      <div class="btns">
        <button id="clear" class="danger">Clear (C)</button>
        <button id="save" class="primary">Save PNG</button>
        <button id="toggleVideo" class="ghost">Hide Video (V)</button>
        <button id="erase" class="ghost">Eraser (E)</button>
      </div>
      <div class="tips">
        <p><b>How to draw</b>: Pinch your <b>thumb + index</b> to start drawing. Open your hand to stop. The canvas mirrors like a selfie.</p>
        <p><b>Shortcuts</b>: <span class="kbd">E</span> toggle eraser, <span class="kbd">C</span> clear, <span class="kbd">V</span> show/hide video, <span class="kbd">S</span> save.</p>
        <p><b>Notes</b>: Good lighting helps tracking. Keep your hand within the video frame.</p>
      </div>
    </aside>
  </div>

  <div class="toast" id="toast"></div>

  <!-- MediaPipe Hands + utils (CDN) -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.min.js"></script>

  <script>
    const video = document.getElementById('video');
    const overlay = document.getElementById('overlay');
    const paint = document.getElementById('paint');
    const stage = document.getElementById('stage');
    const statusEl = document.getElementById('status');
    const dot = document.getElementById('dot');
    const toast = document.getElementById('toast');

    const colorEl = document.getElementById('color');
    const sizeEl = document.getElementById('size');
    const smoothEl = document.getElementById('smooth');
    const pinchEl = document.getElementById('pinch');
    const sizeLabel = document.getElementById('sizeLabel');
    const smoothLabel = document.getElementById('smoothLabel');
    const pinchLabel = document.getElementById('pinchLabel');
    const clearBtn = document.getElementById('clear');
    const saveBtn = document.getElementById('save');
    const eraseBtn = document.getElementById('erase');
    const toggleVideoBtn = document.getElementById('toggleVideo');

    // Resize canvases to match stage
    function fitCanvases(){
      const rect = stage.getBoundingClientRect();
      [overlay, paint].forEach(c => { c.width = rect.width; c.height = rect.height; });
    }
    addEventListener('resize', fitCanvases);
    fitCanvases();

    const octx = overlay.getContext('2d');
    const pctx = paint.getContext('2d');
    pctx.lineCap = 'round';
    pctx.lineJoin = 'round';

    let isDrawing = false;
    let isEraser = false;
    let last = null; // last smoothed point

    function lerp(a,b,t){ return a + (b-a)*t; }

    function toScreen(xNorm, yNorm){
      // MediaPipe gives normalized coords. Our video is mirrored, so mirror x.
      return {
        x: (1 - xNorm) * overlay.width,
        y: yNorm * overlay.height
      };
    }

    function setStatus(text, live=false){
      statusEl.textContent = text;
      dot.classList.toggle('live', live);
    }

    function showToast(msg, cls=''){
      toast.textContent = msg;
      toast.className = 'toast ' + cls;
      toast.style.display = 'block';
      setTimeout(()=> toast.style.display='none', 2200);
    }

    // UI events
    sizeEl.addEventListener('input', ()=> sizeLabel.textContent = sizeEl.value + 'px');
    smoothEl.addEventListener('input', ()=> smoothLabel.textContent = smoothEl.value);
    pinchEl.addEventListener('input', ()=> pinchLabel.textContent = pinchEl.value);

    clearBtn.addEventListener('click', ()=>{
      pctx.clearRect(0,0,paint.width,paint.height);
    });

    saveBtn.addEventListener('click', ()=>{
      // Compose paint over a transparent background at canvas size
      const out = document.createElement('canvas');
      out.width = paint.width; out.height = paint.height;
      const ctx = out.getContext('2d');
      ctx.drawImage(paint,0,0);
      const url = out.toDataURL('image/png');
      const a = document.createElement('a');
      a.href = url; a.download = 'AirDraw.png'; a.click();
      showToast('Saved drawing as PNG');
    });

    eraseBtn.addEventListener('click', ()=>{
      isEraser = !isEraser;
      eraseBtn.textContent = isEraser ? 'Eraser: ON (E)' : 'Eraser (E)';
      eraseBtn.classList.toggle('primary', isEraser);
    });

    toggleVideoBtn.addEventListener('click', ()=>{
      video.style.opacity = (video.style.opacity === '0') ? '.4' : '0';
      toggleVideoBtn.textContent = (video.style.opacity === '0') ? 'Show Video (V)' : 'Hide Video (V)';
    });

    // Keyboard shortcuts
    addEventListener('keydown', (e)=>{
      if(e.key.toLowerCase()==='c') clearBtn.click();
      if(e.key.toLowerCase()==='s') saveBtn.click();
      if(e.key.toLowerCase()==='e') eraseBtn.click();
      if(e.key.toLowerCase()==='v') toggleVideoBtn.click();
    });

    // MediaPipe Hands setup
    const hands = new Hands({
      locateFile: (file)=> `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
    });
    hands.setOptions({
      maxNumHands: 1,
      modelComplexity: 1,
      minDetectionConfidence: 0.6,
      minTrackingConfidence: 0.6
    });

    hands.onResults(onResults);

    // Camera feed
    let camera = null;
    async function initCamera(){
      try {
        setStatus('Requesting camera…');
        const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user' }, audio: false });
        video.srcObject = stream;
        await video.play();
        setStatus('Tracking hand — pinch thumb + index to draw', true);

        // Use CameraUtils so Hands receives frames efficiently
        camera = new Camera(video, {
          onFrame: async () => {
            await hands.send({ image: video });
          },
          width: 1280,
          height: 720
        });
        camera.start();
      } catch (err){
        console.error(err);
        setStatus('Camera blocked. Allow access and refresh.');
        showToast('Camera permission needed', 'warn');
      }
    }

    initCamera();

    function onResults(results){
      octx.clearRect(0,0,overlay.width,overlay.height);
      if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0){
        isDrawing = false; last = null; return; }

      const landmarks = results.multiHandLandmarks[0];

      // Draw skeleton overlay (subtle)
      octx.save();
      octx.globalAlpha = .65;
      octx.lineWidth = 2;
      octx.strokeStyle = 'rgba(146, 179, 255, .6)';
      octx.fillStyle = 'rgba(90, 161, 255, .5)';
      drawConnectors(octx, landmarks, HAND_CONNECTIONS);
      drawLandmarks(octx, landmarks);
      octx.restore();

      // Fingertip and pinch logic
      const tip = toScreen(landmarks[8].x, landmarks[8].y);     // index tip
      const thumb = toScreen(landmarks[4].x, landmarks[4].y);   // thumb tip

      // Compute normalized pinch distance in original normalized space (not screen) for scale invariance
      const dx = landmarks[8].x - landmarks[4].x;
      const dy = landmarks[8].y - landmarks[4].y;
      const pinchDist = Math.hypot(dx, dy);
      const pinchThreshold = parseFloat(pinchEl.value);

      const smooth = parseFloat(smoothEl.value);
      const point = last ? { x: lerp(last.x, tip.x, 1 - smooth), y: lerp(last.y, tip.y, 1 - smooth) } : tip;
      last = point;

      // Visualize pointer
      octx.save();
      octx.beginPath();
      octx.arc(point.x, point.y, 6, 0, Math.PI*2);
      octx.fillStyle = pinchDist < pinchThreshold ? '#6ee7b7' : '#5aa1ff';
      octx.fill();
      octx.restore();

      // Start/stop drawing with pinch
      if (pinchDist < pinchThreshold){
        // begin or continue drawing
        const size = parseInt(sizeEl.value, 10);
        if (isEraser){
          pctx.globalCompositeOperation = 'destination-out';
          pctx.strokeStyle = 'rgba(0,0,0,1)';
          pctx.lineWidth = size * 1.6;
        } else {
          pctx.globalCompositeOperation = 'source-over';
          pctx.strokeStyle = colorEl.value;
          pctx.lineWidth = size;
        }

        if (!isDrawing){
          pctx.beginPath();
          pctx.moveTo(point.x, point.y);
          isDrawing = true;
        } else {
          pctx.lineTo(point.x, point.y);
          pctx.stroke();
        }
      } else {
        // stop stroke smoothly
        if (isDrawing){
          pctx.closePath();
          isDrawing = false;
        }
      }
    }

    // Handle tab visibility to avoid runaway CPU
    document.addEventListener('visibilitychange', ()=>{
      if (document.hidden){ camera && camera.stop(); setStatus('Paused (tab hidden)'); }
      else { camera && camera.start(); setStatus('Tracking hand — pinch thumb + index to draw', true); }
    });

  </script>
</body>
</html>
